## 1.ArrayList实现了什么

✅ ​List：即支持最基础的增删改查（此处“改”更客观来说是访问元素操作）
✅ RandomAccess：随机存取，即直接通过索引获得元素
✅ Serializable：支持序列化
✅ Cloneable：支持深浅拷贝操作

## 2.与LinkedList的比较

老生常谈中，好像这两者的比较就是数组与链表的势不两立。但在封装成类之后并没有那么矛盾。
- 时间复杂度：
  ArrayList以其众所周知的随机存取功能，即支持直接通过索引获取元素以便进行下一步修改。但实践中我们是要拿到索引还是要通过遍历（甚至是性能极差的普通for循环）。所以这个优势忽略不计。而ArrayList的缺点是增删操作，特别是插入或删除列表中间元素时时间复杂度为O(n)，而实践中我们很少在业务中进行删除操作（一般是根据数据库删除或筛选），增加操作也常常时添加到列表结尾。因此，这个缺点也几乎很少触发。
  LinkedList也是如此，除了最忌讳的用普通for+get(i)恐怖时间复杂度。被吹捧的增删操作也需要先用O(n)时间复杂度将索引先挪到增删处，被诟病的获取元素需要遍历也因实践中极少使用（一般数据库查询）而影响很小。
- 存储空间：
  ArrayList会预留部分空间，LinkedList则需要存储​前驱和后继信息

**选择建议：**

| ​**​场景​**​   | ​**​推荐结构​**​                 | ​**​理由​**​                          |
| ------------ | ---------------------------- | ----------------------------------- |
| 频繁随机访问       | `ArrayList`                  | O(1) 访问，CPU 缓存友好。                   |
| 高频尾部插入/删除    | `ArrayList`                  | 均摊 O(1)，内存紧凑。                       |
| 高频头部/中间插入/删除 | `LinkedList`                 | 无需移动元素（但需遍历到位置）。                    |
| 内存敏感         | `ArrayList`                  | `LinkedList` 的节点开销更大（每个元素额外存储前后指针）。 |
| 并发场景         | `CopyOnWriteArrayList` 或并发队列 | 标准 `ArrayList`/`LinkedList` 非线程安全。  |
