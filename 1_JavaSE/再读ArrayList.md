## 1.ArrayList实现了什么

✅ ​List：即支持最基础的增删改查（此处“改”更客观来说是访问元素操作）
✅ RandomAccess：随机存取，即直接通过索引获得元素
✅ Serializable：支持序列化
✅ Cloneable：支持深浅拷贝操作

## 2.与LinkedList的比较

老生常谈中，好像这两者的比较就是数组与链表的势不两立。但在封装成类之后并没有那么矛盾。
- 时间复杂度：
  ArrayList以其众所周知的随机存取功能，即支持直接通过索引获取元素以便进行下一步修改。但实践中我们是要拿到索引还是要通过遍历（甚至是性能极差的普通for循环）。所以这个优势忽略不计。而ArrayList的缺点是增删操作，特别是插入或删除列表中间元素时时间复杂度为O(n)，而实践中我们很少在业务中进行删除操作（一般是根据数据库删除或筛选），增加操作也常常时添加到列表结尾。因此，这个缺点也几乎很少触发。
  LinkedList也是如此，除了最忌讳的用普通for+get(i)恐怖时间复杂度。被吹捧的增删操作也需要先用O(n)时间复杂度将索引先挪到增删处，被诟病的获取元素需要遍历也因实践中极少使用（一般数据库查询）而影响很小。
- 存储空间：
  ArrayList会预留部分空间，LinkedList则需要存储​前驱和后继信息

**选择建议：**

| ​**​场景​**​   | ​**​推荐结构​**​                 | ​**​理由​**​                          |
| ------------ | ---------------------------- | ----------------------------------- |
| 频繁随机访问       | `ArrayList`                  | O(1) 访问，CPU 缓存友好。                   |
| 高频尾部插入/删除    | `ArrayList`                  | 均摊 O(1)，内存紧凑。                       |
| 高频头部/中间插入/删除 | `LinkedList`                 | 无需移动元素（但需遍历到位置）。                    |
| 内存敏感         | `ArrayList`                  | `LinkedList` 的节点开销更大（每个元素额外存储前后指针）。 |
| 并发场景         | `CopyOnWriteArrayList` 或并发队列 | 标准 `ArrayList`/`LinkedList` 非线程安全。  |
## 3.关于ArrayList的扩容机制

首先，说到扩容就要说到初始化。其实ArrayList定义了三种初始化方式：**有参、无参、引入**。
用无参举例比较容易，刚开始没有参数。会分配一个空数组给ArrayList。
如果开始add()添加元素，那么数组就需要扩容。
1. ensureCapacityInternal() 入口函数，目的是确保数组容量。只做下面方法调用
2. calculateCapacity() 计算需要的容量，一般返回默认长度或是所需存放元素个数
3. ensureExplicitCapacity() 判断是否需要扩容。拿上一步calculateCapacity()返回结果与当前数组长度相比
4. 如果数组长度无法满足元素的存储需求，则进行grow()扩容，扩容机制为当前数组长度的1.5倍
5. 使用位运算，newCapacity = oldCapacity + (oldCapacity >> 1);
6. 进行一系列比较：
   - 将newCapacity和所需存放元素个数进行比较，如果newCapacity不够就直接按照所需存放元素个数作为newCapacity。
   - 将newCapacity与MAX_ARRAY_SIZE作比较，如果newCapacity更大，就将所需存放元素个数和MAX_ARRAY_SIZE作比较后，将更大的值赋给newCapacity。

可以看到，需要扩容时一直是以newCapacity作为核心变量，而不是所需存放元素个数。这避免了频繁扩容，当然，也使得代码维护难度大了一丢丢。此外还有一个比较有意思的是MAX_ARRAY_SIZE并不代表最大值，而是Integer.MAX_VALUE - 8。这个8作为预留数组的部分信息（如length）进入JVM，当第六步最后一次所需存放元素个数和MAX_ARRAY_SIZE作比较时，若是所需存放元素个数更大，那就将这个真正的最大值Integer.MAX_VALUE赋给数组。这样也不用记录数组信息，因为length就是最大值。