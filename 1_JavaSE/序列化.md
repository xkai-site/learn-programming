# 序列化Serializable

我们平时处理业务的时候，面向对象编程会使业务逻辑更加清晰。但实际上计算机只认识字节流，需要网络传输或者数据存储时都需要以字节流形式。
因此字节流和对象之间的转化需要序列化和反序列化。
序列化：对象->字节流
反序列化：字节流->对象

## 快速入门

```
import java.io.*;
	// 第一步：实现Serializable接口（空接口）
 class User implements Serializable {  // [!code focus]
 	// 第二步：添加版本号
     private static final long serialVersionUID = 1L;  // [!code focus]
     
     private String name;
     private transient String password; // transient不参与序列化
 }

 	// 第三步：序列化对象
 try (ObjectOutputStream out = new ObjectOutputStream(
         new FileOutputStream("user.data"))) {  // [!code focus]
     out.writeObject(new User("张三", "123456"));
 }

 	// 第四步：反序列化
 try (ObjectInputStream in = new ObjectInputStream(
         new FileInputStream("user.data"))) {
     User user = (User) in.readObject();  // [!code focus]
     System.out.println(user.getName()); // 输出"张三"
     System.out.println(user.getPassword()); // 输出null（因为transient）
 }
```



## 现实实践

我们知道，只要后端需要与前端、数据库交互，就需要进行对应的序列化或反序列化。但实际操作中我们会发现项目中的类常常没有序列化也可以正常交互。这其实是因为一些框架已经实现了序列化处理。比如`SpringBoot`，`Mybatis`等等，他们使用`JSON`/`XML`实现文本序列化。而需要更高性能场景的情况（如 Dubbo、gRPC、Kafka）优先使用二进制协议。

因此，我们在现代项目中比较少使用`Serializable`的序列化了。仍需`Serializable`的场景主要为旧版RMI（远程方法调用）以及自己想要快速实现想法（比如将对象以文件形式保存）。