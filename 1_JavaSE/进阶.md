# 初识设计模式

### 单例模式

某个类只允许存在一个对象实例，并且只提供一个获取对象实例的方法。（相当于不允许直接new()，只能类内部创建，外部使用get调用）

解决问题：有一个类非常耗费资源的情况下，如何避免反复创建

### 饿汉式

解决方式：饿汉式，在使用类时就已创建对象。

```java
public class test {
    public static void main(String[] args) {
        GirlFriend girlFriend = GirlFriend.getInstance();
        System.out.println(girlFriend);
    }
}

class GirlFriend{
    private String name;
    //构造对象
    private static GirlFriend girlFriend = new GirlFriend("girlFriend");
    //将构造器私有化
    private GirlFriend(String name){
        this.name = name;
    }
    //给外界暴露调用
    public static GirlFriend getInstance() {
        return girlFriend;	//这里自始至终只做返回，避免了反复创建对象问题
    }
    //美化输出，重写toString
    @Override
    public String toString() {
        return name;
    }
}
```

饿汉式的问题：可能类被构建，但对象没有使用，导致资源泄露

### 懒汉式

解决方式：懒汉式延迟初始化，在使用到对象时才创建对象，避免资源泄露

```java
//将暴露接口方法改为
    //给外界暴露调用
    public static GirlFriend getInstance() {
        if (girlFriend==null){
            girlFriend = new GirlFriend("girlFriend");
        }
        return girlFriend;
    }
```

懒汉式的问题：高并发下线程不安全，需要加同步锁。

还有两种实践：
```java
//静态内部类（大多数情况下其实用这个）
public class Singleton {
    private Singleton() {}
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.INSTANCE;	//Holder使用Java类加载机制，无需手动判空（否则可能需要加锁）
    }
}
```

```java
//双重检查锁（高并发场景用这个）
public class Singleton {
    private static volatile Singleton instance;	//使变量被线程可见
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

