# 基础

## 重写和重载：

- 重写是方法重写，也叫Override。指子类重新定义父类方法，除了具体业务之外其他的方法名、返回类型、参数都要一致
- 重载是指一个类定义多个同名方法，但参数和返回类型不一定相同

# 集合

Java中的集合一般分为Collection和Map，在此之下Collection又分成`List`,`Set`,`Quene`，Map主要形式是`HashMap`。
我常用的是`List`和`Map`。
`List`的应用比较多，比如实现类`ArrayList`，可以用来返回处理数据库查出的数据。而`LinkedList`在Java中是双向链表，也实现了`Quene`接口下的`Duque`接口，所以它能够实现队列或者栈的基础功能，也能够适应频繁增减的操作。比如Web3的区块链机制的“链”就借鉴了链表思想。
而`Map`我比较常用的是`HashMap`，比如在Redis等缓存中间层，存储键值对的效率比较高，查找也更加灵活。或是在JSON解析条件下，JSON作为键值对结构，使用HashMap解析也更加有天然，无需定义DTO。（可以结合项目去说）

# 红黑树

产生背景：二叉搜索树可能极度不平衡，比如会退化成线性链表

概念：红黑树是一种自平衡二叉树，通过每个节点添加存储位表示颜色，以及对路径节点的颜色进行约束，确保了红黑树的任意路径不会比其他路径长出两倍。

红黑树五条规则：

1. 根节点是黑色
2. 节点只有红色和黑色
3. 叶子结点，也称为NIL哨兵节点，是黑色的
4. 红节点的子节点是黑色的（但黑节点的子节点可能是黑色）
5. 从任意节点到每个叶子的路径所经过的黑色节点数量相同（不包含根节点，包含NIL节点，这个数量也称黑高）

![image-20250618094607789](C:\Users\HP\Documents\Obsidian Vault\Summary\img\红黑树)


特性：

- 黑高 = h
- 最短路径长度 = h（全黑）
- 最长路径长度 ≤ 2h（红黑交替）

因此最长路径最多是最短路径的两倍。

Java的TreeMap和TreeSet实现了红黑树。

# HashMap

1. HashMap的原理：
   使用键值对存储数据，核心是将键映射到索引上，在jdk8之后采用数组+链表+红黑树解决哈希冲突。哈希冲突可以理解为，哈希函数有可能会将不同输入处理为同一输出。这是因为哈希函数输出的数量是一定的，而理论上输入是无限的。HashMap用键的hashCode()去计算哈希值，并且用(n-1)&hash确定位置。

2. HashMap的扩容
   HashMap的默认初始容量为16，负载因子为0.75，扩容机制是*2。
   也就是说超过12个就开始扩容为32个。

3. HashMap的问题：
   HashMap不是线程安全的，在多线程环境下使用可能会导致数据不一致等问题。

   - **数据丢失**：多个线程同时进行put操作时，可能因为竞争条件而导致部分数据未被正确写入。
   - **无限循环**：在扩容过程中，由于链表节点的反转操作，若多个线程同时进行扩容，可能导致链表成环，进而引发死循环。 解决方案可以使用ConcurrentHashMap或者通过Collections.synchronizedMap方法包装HashMap来实现线程安全。

   ## Hashtable

   1. 如何实现线程安全？
      Hashtable通过在方法级别上使用`synchronized`关键字来实现线程安全。这意味着每个修改或访问Hashtable的操作（如put、get、remove等）都会被同步，从而确保在同一时刻只有一个线程可以执行这些操作。
   2. HashTable的扩容机制：
      初始容量为11，负载因子为0.75，扩容机制为*2+1

# 线程

## 用多线程吗，如何创建线程？

继承Thread类或者实现Runnable接口。因为Java不支持多重继承，即多个子类继承一个父类。所以一般实现Runnable接口。

```java
// 方法一：继承Thread类
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running.");
    }
}
MyThread t = new MyThread();
t.start();

// 方法二：实现Runnable接口
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread is running.");
    }
}
Thread t2 = new Thread(new MyRunnable());
t2.start();
```





## 线程池的好处

线程池一般用于多个不相关的耗时任务

- 避免重复创建销毁线程的消耗
- 提升速度
- 提高线程可管理性

## Executor框架
缺陷：

- 不会自动关闭，需要手动shutdown

- 配置参数不当容易影响性能

- 线程池复用线程会导致ThreadLocal污染
  ```java
  ThreadLocal<String> context = new ThreadLocal<>();
  executor.submit(() -> {
      context.set("value");
      // 线程被复用后，下次任务会看到旧的value
  });
  ```

## ThreadPoolExecutor类（Executor框架中核心类）

`ThreadPoolExecutor` 3 个最重要的参数：

- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

```
[新任务到来]
  ↓
检查核心线程corePoolSize是否都在忙？
  ├─ 否 → 创建新核心线程执行
  ↓
  ├─ 是 → 检查队列是否已满？
      ├─ 否 → 放入队列workQueue等待
      ↓
      ├─ 是 → 检查线程数是否已达最大值？maximumPoolSize
          ├─ 否 → 创建新线程执行
          ↓
          ├─ 是 → 执行拒绝策略
```

示例：
```java
import java.util.concurrent.*;

public class SimpleThreadPool {
    public static void main(String[] args) {
        // 创建线程池：核心2线程，最大4线程，队列容量2
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,  // 核心线程数
            4,  // 最大线程数
            60, // 空闲线程存活时间
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2) // 任务队列容量
        );
        
        // 提交6个任务
        for (int i = 1; i <= 6; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("执行任务" + taskId + " 线程:" + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // 模拟任务耗时
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        executor.shutdown(); // 关闭线程池
    }
}
```

总之：任务先看核心线程是否空闲，不空闲就看队列是否已满，如果也满了就看是否到了最大线程数，如果还到了那就等一会。
这里有个例子：新任务到来时：

1. 先看有没有空闲的服务员(线程) ➔ 有就立即服务
2. 如果服务员都忙 ➔ 让顾客在等候区(队列)坐着等
3. 如果等候区也满了 ➔ 叫临时服务员(新建线程)来帮忙
4. 如果连临时服务员也招满了 ➔ 拒绝新顾客(执行拒绝策略)

创建方式：

1. **`ThreadPoolExecutor`构造函数来创建（推荐）**

2. **`Executor` 框架的工具类 `Executors` 来创建**（可创建多种类型线程池）
   弊端：创建的线程池使用队列的长度是`Integer.MAX_VALUE`，所以可看做是无界的。若堆积大量请求可能会导致OOM（内存不足）。

## 不同线程池对应的队列

1. FixedThreadPool：
   最大线程数=核心线程数
   无界队列

2. SingleThreadExecutor：
   最大线程数=核心线程数=1
   无界队列

3. CachedThreadPool：

   最大线程数是无限的，而队列没有容量

4. ScheduledThreadPool和SingleThreadScheduledExecutor较为特殊，ScheduledThreadPool采取的队列中实现了排序逻辑，而SingleThreadScheduledExecutor的队列能够动态扩容。

==技术栈TODO：具体代码分析==

常见对比：

- `Runnable`vs`Callable`
  两者都是接口，`Runnable`非常通用，不支持返回值或抛出异常。

- `execute()`vs`submit()`

  - `execute()`无返回值，无法判断；而`submit()`有返回Future对象，其中的get()能够起到等待返回的作用
  - `execute()`需要自定义异常处理，而`submit()`可以通过Future对象处理异常

- `shutdown()`vs`shutdownNow()`
  `shutdown()`只是将线程池关闭，队列中的任务仍然需要执行
  `shutdownNow()`则是将整个任务终止

- `isShutdown()`vs`isTerminated()`

  `isShutdown`判断是否执行`shutdown`
  `isTerminated`判断是否执行`shutdown`并且任务全部完成


# 抽象类

抽象类是不能被实例化的特殊类，主要用于定义一些接口能让子类去实现。

抽象类与接口的区别？
抽象类也可以有一般类中存在的成员变量，甚至有具体实现的方法。而接口更多的是定义纯粹的行为规范。因此，抽象类适用于某些方法需要统一，某些方法又需要子类具体实现的情况。

# 拷贝

深拷贝和浅拷贝的区别？
对于简单数据类型来说，深浅拷贝都是创建独立副本。
而对于复杂数据类型，深拷贝是复制一份相同的副本与源对象独立，浅拷贝只是指向源对象的地址。（所以源对象变动会导致浅拷贝对象的变动）

深拷贝和浅拷贝的使用代码：
```java
// 对基本类型数组的clone()是深拷贝
int[] nums = {1, 2, 3};
int[] copied = nums.clone(); 

//对对象数组的clone()是浅拷贝
String[] names = {"A", "B"};
String[] namesCopy = names.clone(); 
```

### 集合工具类的拷贝方法

- **`Collections.copy()`**：浅拷贝
- `**new ArrayList<>(originalList)**`： 浅拷贝

# JVM

首先一个java文件写出来后，会先通过编译器编译成字节码class，再通过jvm解释成机器码去执行。因此这一步也相当于解耦，将字节码放到不同系统对应的JVM去处理，使得java文件无需根据系统环境改动。

JVM就是不同系统下运行Java程序的虚拟机环境，分为类加载器、运行时数据区、执行引擎。

- 类加载器：加载class文件
- 运行时数据区：存储变量和对象
  - 方法区：存储已加载的类/编译后的代码（类加载优先级较高）
  - 堆：线程共享，放的是对象实例，也是垃圾回收的主要区域
  - 虚拟机栈：每个线程都有私有栈，存储方法执行时的局部变量，操作数栈等信息
  - 本地方法栈：和上述类似，但服务于本地方法
  - 程序计数器：记录当前线程执行的字节码指令地址
- 执行引擎：将class编译解释为机器码

垃圾回收（GC）机制：
由JVM或运行时环境负责，当释放不再使用的对象的内存空间。这就和C语言著名的指针有些区别，Java避免程序员忘记释放所造成的内存泄漏。

- 引用计数：对象维护一个引用计数器，记录引用数量。（当数量为0时可安全回收）
- 标记-清除：
  标记：遍历所有可达对象进行标记
  清除：扫堆，未标记的对象进行回收清除（容易产生内存碎片）
- 复制：将存活的对象先复制到另一区域，再进行清除（内存利用率低）
- 标记-整理：
  类似标记-清除，先标记可达对象，再把存货对象移动到堆的另一端（比较慢）
- 分代垃圾回收：频繁对年轻代进行垃圾回收，提高垃圾回收效率。

# MySQL

## MySQL索引分类

- 主键索引：使用主键，必须唯一且非空
- 唯一索引：必须唯一但允许空值
- 普通索引：基本类型，可以加速查询
- 全文索引
- 组合索引
- 空间索引

# 分布式锁

锁的互斥性：如果一个线程拿到锁，那么另一个没拿到就没法继续往下
redis setnx：先判断后释放（Lua脚本保证原子性）

setnx原子性：Redis天然保证（SET if not exists）

若这个有锁线程挂了：加锁释放时间
若这个线程还没执行完：看门狗机制
将看门狗设置为守护线程（？如何守护）
若递归/方法调用，同一个线程需要多次获取锁
因此需要是实现可重入锁：锁计数器（重入一次加一次）

分布式锁实现可重入：

1. Redis哈希结构：redission实现方案（要锁的为key，线程id+uuid为field，重入次数为value）。因为在集群情况下线程id可能会重复
2. ConcurrentHashMap，map中的value作为锁计数器

没有抢到锁的线程怎么办：（阻塞锁，也是一般公司的设计）

1. 没有抢到锁的去自旋抢锁
2. redission：订阅机制，线程订阅抢到锁的线程，期间需要超时时间防止一直抢不到。

主从架构带来的锁丢失问题：（大集群）
当Redis主节点挂了，那么从节点转从为主过程中就会丢失锁信息。
因此redission有个联锁机制，需要多主节点共同加锁，而红锁机制更加灵活，只需要为50%以上的主节点加锁（半数以上满足了互斥性），但这并不常用。

# 日志

## 日志级别（LogLevel）

常见级别有：DEBUG < INFO < WARN < ERROR < FATAL

## 如何实现一个日志模块（只是基础）

1. 先进行业务分析，定义格式，比如`日志级别_下划线_线程名_消息`
2. 采用单例模式，比如Logger统一写入，饿汉式和懒汉式
3. 异步写入，使用消息队列+非主线程异步写入日志
